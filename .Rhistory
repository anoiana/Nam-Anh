# convert array to list and data.frame (data.frame isn't changed after removing 2 cols)
d = lapply(1:S, function(i) as_tibble(dat_from_trials1[,,i]))
for(i in drop_ind ){
d[[unique(i[,"row"])]]<- d[[unique(i[,"row"])]][,-i[,"col"]]
}
dat_from_trials1b<- lapply(d, as.matrix) # removed futile treatment(s)
### drop 2 treatments (remain 1 trt)
drop1= purrr::keep(dat_from_trials1b, ~ncol(.)==1)
# probability that trt3 is superior
# p1 = ifelse(is.null(drop1[1][[1]]),0, sum(sapply(drop1,colnames)=="trt3")/S) # power
p1 = ifelse(is.null(drop1[1][[1]]),0, length(drop1)/S)
### drop 1 treatment (remain 2)
drop2 = purrr::keep(dat_from_trials1b, ~ncol(.)==2)
# consider possibility of trt3 win
# compare remained trts
if(is.null(drop2[1][[1]])){
p2<- 0
} else{
p2<-
sapply(drop2, function(dat){
trt = colnames(dat)
pos1 = GetPosMean(R, x = dat[,trt[1]], sig_sq = pr[trt[1],"Variance"], mu0 =pr[trt[1],"Mean"], v_sq =v_sq, beta = beta)
pos2 = GetPosMean(R, dat[,trt[2]], sig_sq = pr[trt[2],"Variance"], mu0 =pr[trt[2],"Mean"], v_sq = v_sq, beta = beta)
r= mean(pos2-pos1 <0)
return(r)
})%>% {sum(.>0.99)/S + sum(.<0.01)/S} # This is like SUCRA but we need to consider all SUCRAs
# so we also need to consder all treatments as optimal.
## Here we are wrong again because we need both > 0.95 AND < 0.05.
## Plus we need the proportion of trials that achieve this...
## Plus, we don't only want treatment 3...
}
### no trt dropped
drop3<- purrr::keep(dat_from_trials1b, ~ncol(.)==3)
# obtain SUCRA for all available patients
if(is.null(drop3[1][[1]])){
p3 = 0
} else{
r<-
sapply(drop3, function(d){
pos_mean<-
purrr::set_names(c("trt1","trt2","trt3"))%>%
vapply(function(i){
GetPosMean(R, x = d[,i], v_sq = v_sq, mu0 = pr[i,"Mean"], sig_sq =  pr[i,"Variance"], beta = beta)
}, numeric(R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) sapply(purrr::set_names(1:3), function(z) mean(i==z) )  )
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
# plot(density(r[1,]), xlim = c(min(c(r)), max(c(r))))
# lines(density(r[2,]), col = "red")
# lines(density(r[3,]),  col = "blue")
p3<- apply(r, 1, function(x){x > 0.99}) %>% sum(.)/S
# sum(r["3",]>0.95)/S # power
## Need to include all three treatments
## Need to calculate probability WRT to number of simulations
}
p1+p2+p3
})
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1)
dat_from_trials2<- # different mean, same sd (for power)
replicate(S,vapply(pr[,"Mean"], rnorm, n = n, sd = sqrt(v_sq), FUN.VALUE = rep(NA_real_,n)))
dimnames(dat_from_trials2)[[2]]<- paste0("trt",1:3)
###################
sucra2<-
apply(dat_from_trials2,3, function(d){
pos_mean<-
c("trt1","trt2","trt3")%>%
vapply(function(i){
GetPosMean(R, x = d[1:45,i], v_sq = v_sq, mu0 = pr[i,"Mean"],sig_sq = pr[i,"Variance"], beta = beta)
}, rep(NA_real_,R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) vapply(purrr::set_names(1:3), function(z) mean(i==z), c(NA_real_)))
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
# type I error rate
sucra1<-
apply(dat_from_trials1,3, function(d){ # for each each trial d
pos_mean<-
vapply(pr$ID,function(i){
GetPosMean(R, x = d[1:55,i], sig_sq = pr[i,"Variance"], mu0 = pr[i,"Mean"],v_sq = v_sq,beta = beta)
}, rep(NA_real_,R) )
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) vapply(`names<-`(1:3,1:3), function(z) mean(i==z),c(NA_real_)))
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
ci_tp1 = c(sucra1)%>%
{c("mean" = mean(.), HDInterval::hdi(.,0.95) )}
for( i in 1:3){
f = switch(ifelse(i==1,1,2), plot,lines)
cb = c(sucra1)
f(density(sucra1[i,]),  col = alpha(c("red","green","blue")[i],0.4),xlim = c(min(cb), max(cb)))
abline(v = HDInterval::hdi(sucra1[i,],0.95), col = alpha(c("red","green","blue")[i],0.4))
}
lines(density(c(sucra1)), lwd = 2, lty = 2 )
abline(v = HDInterval::hdi(c(sucra1),0.95), lwd = 2, lty = 2)
# obtain index of dropped trial and trt
beta = 10
type1<-
sapply(c(0.2,0.25,0.3,0.35,0.4,0.45), function(k){
drop_ind = which(t(sucra1 < k), arr.ind = T)
drop_ind = lapply(unique(drop_ind[,1]), function(i){
d = drop_ind[drop_ind[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
# convert array to list and data.frame (data.frame isn't changed after removing 2 cols)
d = lapply(1:S, function(i) as_tibble(dat_from_trials1[,,i]))
for(i in drop_ind ){
d[[unique(i[,"row"])]]<- d[[unique(i[,"row"])]][,-i[,"col"]]
}
dat_from_trials1b<- lapply(d, as.matrix) # removed futile treatment(s)
### drop 2 treatments (remain 1 trt)
drop1= purrr::keep(dat_from_trials1b, ~ncol(.)==1)
# probability that trt3 is superior
# p1 = ifelse(is.null(drop1[1][[1]]),0, sum(sapply(drop1,colnames)=="trt3")/S) # power
p1 = ifelse(is.null(drop1[1][[1]]),0, length(drop1)/S)
### drop 1 treatment (remain 2)
drop2 = purrr::keep(dat_from_trials1b, ~ncol(.)==2)
# consider possibility of trt3 win
# compare remained trts
if(is.null(drop2[1][[1]])){
p2<- 0
} else{
p2<-
sapply(drop2, function(dat){
trt = colnames(dat)
pos1 = GetPosMean(R, x = dat[,trt[1]], sig_sq = pr[trt[1],"Variance"], mu0 =pr[trt[1],"Mean"], v_sq =v_sq, beta = beta)
pos2 = GetPosMean(R, dat[,trt[2]], sig_sq = pr[trt[2],"Variance"], mu0 =pr[trt[2],"Mean"], v_sq = v_sq, beta = beta)
r= mean(pos2-pos1 <0)
return(r)
})%>% {sum(.>0.99)/S + sum(.<0.01)/S} # This is like SUCRA but we need to consider all SUCRAs
# so we also need to consder all treatments as optimal.
## Here we are wrong again because we need both > 0.95 AND < 0.05.
## Plus we need the proportion of trials that achieve this...
## Plus, we don't only want treatment 3...
}
### no trt dropped
drop3<- purrr::keep(dat_from_trials1b, ~ncol(.)==3)
# obtain SUCRA for all available patients
if(is.null(drop3[1][[1]])){
p3 = 0
} else{
r<-
sapply(drop3, function(d){
pos_mean<-
purrr::set_names(c("trt1","trt2","trt3"))%>%
vapply(function(i){
GetPosMean(R, x = d[,i], v_sq = v_sq, mu0 = pr[i,"Mean"], sig_sq =  pr[i,"Variance"], beta = beta)
}, numeric(R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) sapply(purrr::set_names(1:3), function(z) mean(i==z) )  )
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
p3<- apply(r, 1, function(x){x > 0.99}) %>% sum(.)/S
# sum(r["3",]>0.95)/S # power
## Need to include all three treatments
## Need to calculate probability WRT to number of simulations
}
p1+p2+p3
})
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1)
n
dat_from_trials2<- # different mean, same sd (for power)
replicate(S,vapply(pr[,"Mean"], rnorm, n = n, sd = sqrt(v_sq), FUN.VALUE = rep(NA_real_,n)))
dimnames(dat_from_trials2)[[2]]<- paste0("trt",1:3)
###################
sucra2<-
apply(dat_from_trials2,3, function(d){
pos_mean<-
c("trt1","trt2","trt3")%>%
vapply(function(i){
GetPosMean(R, x = d[1:55,i], v_sq = v_sq, mu0 = pr[i,"Mean"],sig_sq = pr[i,"Variance"], beta = beta)
}, rep(NA_real_,R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) vapply(purrr::set_names(1:3), function(z) mean(i==z), c(NA_real_)))
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
#####
# Red, blue, green plots are separate treatments, black plot is combined one
par(mfrow = c(1,1))
for( i in 1:3){
f = switch(ifelse(i==1,1,2), plot,lines)
cb = c(sucra2)
f(density(sucra2[i,]),  col = c("red","green","blue")[i],xlim = c(min(cb), max(cb)) )
abline(v = HDInterval::hdi(sucra2[i,],0.95), col = c("red","green","blue")[i], lty = 2)
}
thres_drop = 0.35
thres_drop = 0.3
# which datasets are dropped?
n_drop =  which(t(sucra2)< thres_drop, arr.ind = T)
n_drop = lapply(unique(n_drop[,1]), function(i){
d = n_drop[n_drop[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
drop1 = n_drop[sapply(n_drop,function(i) nrow(i) ==1)]%>% lift_dl(rbind)() # drop 1
sum(drop1[,2]!=1) # if trt2 or trt3 is dropped
drop2 = n_drop[sapply(n_drop,function(i) nrow(i) ==2)]%>% lift_dl(rbind)() # drop 2
sum(drop2[,2] ==3) # if trt3 is dropped
drop3 = n_drop[sapply(n_drop,function(i) nrow(i) ==3)]%>% lift_dl(rbind)(); drop3 # drop 3
drop1
drop2
rr<-
apply(dat_from_trials2[,,-drop2[,"row"]],3, function(d){
pos = sapply(c("trt2","trt3"), function(tr){
GetPosMean(R, x = d[,tr], v_sq = v_sq, mu0 = pr[tr,"Mean"], sig_sq = pr[tr,"Variance"])
})
# apply(d,2,mean)["trt3"]
# apply(pos,2, mean)["trt3"]
# pr_inf["mean","trt3"]
#
mean(apply(pos,1,diff) < 0)
})
rr<-
apply(dat_from_trials2[,,-drop2[,"row"]],3, function(d){
pos = sapply(c("trt2","trt3"), function(tr){
GetPosMean(R, x = d[,tr], v_sq = v_sq, mu0 = pr[tr,"Mean"], sig_sq = pr[tr,"Variance"], beta = beta)
})
# apply(d,2,mean)["trt3"]
# apply(pos,2, mean)["trt3"]
# pr_inf["mean","trt3"]
#
mean(apply(pos,1,diff) < 0)
})
rr
length(rr)
drop2
nrow(unique(drop2[,"row"]))
length(unique(drop2[,"row"]))
length(unique(drop2[,"row"]))/S
rr
sum(rr>0.99)/S + length(unique(drop2[,"row"]))/S
drop3
sum(rr>0.99)/S + length(unique(drop2[,"row"]))/S
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1)
## 0.35 and 0.99 - 5% type 1
type1_99<-
sapply(c(0.2,0.25,0.3,0.35,0.4,0.45), function(k){
drop_ind = which(t(sucra1 < k), arr.ind = T)
drop_ind = lapply(unique(drop_ind[,1]), function(i){
d = drop_ind[drop_ind[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
# convert array to list and data.frame (data.frame isn't changed after removing 2 cols)
d = lapply(1:S, function(i) as_tibble(dat_from_trials1[,,i]))
for(i in drop_ind ){
d[[unique(i[,"row"])]]<- d[[unique(i[,"row"])]][,-i[,"col"]]
}
dat_from_trials1b<- lapply(d, as.matrix) # removed futile treatment(s)
### drop 2 treatments (remain 1 trt)
drop1= purrr::keep(dat_from_trials1b, ~ncol(.)==1)
# probability that trt3 is superior
# p1 = ifelse(is.null(drop1[1][[1]]),0, sum(sapply(drop1,colnames)=="trt3")/S) # power
p1 = ifelse(is.null(drop1[1][[1]]),0, length(drop1)/S)
### drop 1 treatment (remain 2)
drop2 = purrr::keep(dat_from_trials1b, ~ncol(.)==2)
# consider possibility of trt3 win
# compare remained trts
if(is.null(drop2[1][[1]])){
p2<- 0
} else{
p2<-
sapply(drop2, function(dat){
trt = colnames(dat)
pos1 = GetPosMean(R, x = dat[,trt[1]], sig_sq = pr[trt[1],"Variance"], mu0 =pr[trt[1],"Mean"], v_sq =v_sq, beta = beta)
pos2 = GetPosMean(R, dat[,trt[2]], sig_sq = pr[trt[2],"Variance"], mu0 =pr[trt[2],"Mean"], v_sq = v_sq, beta = beta)
r= mean(pos2-pos1 <0)
return(r)
})%>% {sum(.>0.99)/S + sum(.<0.01)/S} # This is like SUCRA but we need to consider all SUCRAs
# so we also need to consder all treatments as optimal.
## Here we are wrong again because we need both > 0.95 AND < 0.05.
## Plus we need the proportion of trials that achieve this...
## Plus, we don't only want treatment 3...
}
### no trt dropped
drop3<- purrr::keep(dat_from_trials1b, ~ncol(.)==3)
# obtain SUCRA for all available patients
if(is.null(drop3[1][[1]])){
p3 = 0
} else{
r<-
sapply(drop3, function(d){
pos_mean<-
purrr::set_names(c("trt1","trt2","trt3"))%>%
vapply(function(i){
GetPosMean(R, x = d[,i], v_sq = v_sq, mu0 = pr[i,"Mean"], sig_sq =  pr[i,"Variance"], beta = beta)
}, numeric(R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) sapply(purrr::set_names(1:3), function(z) mean(i==z) )  )
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
p3<- apply(r, 1, function(x){x > 0.99}) %>% sum(.)/S
# sum(r["3",]>0.95)/S # power
## Need to include all three treatments
## Need to calculate probability WRT to number of simulations
}
p1+p2+p3
})
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_99)
## 0.25 and 0.95 - 5% type 1
type1_95<-
sapply(c(0.2,0.25,0.3,0.35,0.4,0.45), function(k){
drop_ind = which(t(sucra1 < k), arr.ind = T)
drop_ind = lapply(unique(drop_ind[,1]), function(i){
d = drop_ind[drop_ind[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
# convert array to list and data.frame (data.frame isn't changed after removing 2 cols)
d = lapply(1:S, function(i) as_tibble(dat_from_trials1[,,i]))
for(i in drop_ind ){
d[[unique(i[,"row"])]]<- d[[unique(i[,"row"])]][,-i[,"col"]]
}
dat_from_trials1b<- lapply(d, as.matrix) # removed futile treatment(s)
### drop 2 treatments (remain 1 trt)
drop1= purrr::keep(dat_from_trials1b, ~ncol(.)==1)
# probability that trt3 is superior
# p1 = ifelse(is.null(drop1[1][[1]]),0, sum(sapply(drop1,colnames)=="trt3")/S) # power
p1 = ifelse(is.null(drop1[1][[1]]),0, length(drop1)/S)
### drop 1 treatment (remain 2)
drop2 = purrr::keep(dat_from_trials1b, ~ncol(.)==2)
# consider possibility of trt3 win
# compare remained trts
if(is.null(drop2[1][[1]])){
p2<- 0
} else{
p2<-
sapply(drop2, function(dat){
trt = colnames(dat)
pos1 = GetPosMean(R, x = dat[,trt[1]], sig_sq = pr[trt[1],"Variance"], mu0 =pr[trt[1],"Mean"], v_sq =v_sq, beta = beta)
pos2 = GetPosMean(R, dat[,trt[2]], sig_sq = pr[trt[2],"Variance"], mu0 =pr[trt[2],"Mean"], v_sq = v_sq, beta = beta)
r= mean(pos2-pos1 <0)
return(r)
})%>% {sum(.>0.95)/S + sum(.<0.05)/S} # This is like SUCRA but we need to consider all SUCRAs
# so we also need to consder all treatments as optimal.
## Here we are wrong again because we need both > 0.95 AND < 0.05.
## Plus we need the proportion of trials that achieve this...
## Plus, we don't only want treatment 3...
}
### no trt dropped
drop3<- purrr::keep(dat_from_trials1b, ~ncol(.)==3)
# obtain SUCRA for all available patients
if(is.null(drop3[1][[1]])){
p3 = 0
} else{
r<-
sapply(drop3, function(d){
pos_mean<-
purrr::set_names(c("trt1","trt2","trt3"))%>%
vapply(function(i){
GetPosMean(R, x = d[,i], v_sq = v_sq, mu0 = pr[i,"Mean"], sig_sq =  pr[i,"Variance"], beta = beta)
}, numeric(R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) sapply(purrr::set_names(1:3), function(z) mean(i==z) )  )
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
p3<- apply(r, 1, function(x){x > 0.95}) %>% sum(.)/S
# sum(r["3",]>0.95)/S # power
## Need to include all three treatments
## Need to calculate probability WRT to number of simulations
}
p1+p2+p3
})
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_95)
type1_97<-
sapply(c(0.2,0.25,0.3,0.35,0.4,0.45), function(k){
drop_ind = which(t(sucra1 < k), arr.ind = T)
drop_ind = lapply(unique(drop_ind[,1]), function(i){
d = drop_ind[drop_ind[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
# convert array to list and data.frame (data.frame isn't changed after removing 2 cols)
d = lapply(1:S, function(i) as_tibble(dat_from_trials1[,,i]))
for(i in drop_ind ){
d[[unique(i[,"row"])]]<- d[[unique(i[,"row"])]][,-i[,"col"]]
}
dat_from_trials1b<- lapply(d, as.matrix) # removed futile treatment(s)
### drop 2 treatments (remain 1 trt)
drop1= purrr::keep(dat_from_trials1b, ~ncol(.)==1)
# probability that trt3 is superior
# p1 = ifelse(is.null(drop1[1][[1]]),0, sum(sapply(drop1,colnames)=="trt3")/S) # power
p1 = ifelse(is.null(drop1[1][[1]]),0, length(drop1)/S)
### drop 1 treatment (remain 2)
drop2 = purrr::keep(dat_from_trials1b, ~ncol(.)==2)
# consider possibility of trt3 win
# compare remained trts
if(is.null(drop2[1][[1]])){
p2<- 0
} else{
p2<-
sapply(drop2, function(dat){
trt = colnames(dat)
pos1 = GetPosMean(R, x = dat[,trt[1]], sig_sq = pr[trt[1],"Variance"], mu0 =pr[trt[1],"Mean"], v_sq =v_sq, beta = beta)
pos2 = GetPosMean(R, dat[,trt[2]], sig_sq = pr[trt[2],"Variance"], mu0 =pr[trt[2],"Mean"], v_sq = v_sq, beta = beta)
r= mean(pos2-pos1 <0)
return(r)
})%>% {sum(.>0.97)/S + sum(.<0.03)/S} # This is like SUCRA but we need to consider all SUCRAs
# so we also need to consder all treatments as optimal.
## Here we are wrong again because we need both > 0.95 AND < 0.05.
## Plus we need the proportion of trials that achieve this...
## Plus, we don't only want treatment 3...
}
### no trt dropped
drop3<- purrr::keep(dat_from_trials1b, ~ncol(.)==3)
# obtain SUCRA for all available patients
if(is.null(drop3[1][[1]])){
p3 = 0
} else{
r<-
sapply(drop3, function(d){
pos_mean<-
purrr::set_names(c("trt1","trt2","trt3"))%>%
vapply(function(i){
GetPosMean(R, x = d[,i], v_sq = v_sq, mu0 = pr[i,"Mean"], sig_sq =  pr[i,"Variance"], beta = beta)
}, numeric(R))
ranking<-
apply(pos_mean, 1, order)%>%
`row.names<-`(paste0("R",1:3))%>%
apply(1, function(i) sapply(purrr::set_names(1:3), function(z) mean(i==z) )  )
cdf_rk <- apply(ranking, 1, cumsum)
# get Surface under the cumulative ranking (SUCRA)
(cdf_rk[1,]+cdf_rk[2,])/2
})
p3<- apply(r, 1, function(x){x > 0.97}) %>% sum(.)/S
# sum(r["3",]>0.95)/S # power
## Need to include all three treatments
## Need to calculate probability WRT to number of simulations
}
p1+p2+p3
})
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_97)
sum(rr>0.97)/S + length(unique(drop2[,"row"]))/S
sum(rr>0.95)/S + length(unique(drop2[,"row"]))/S
sum(rr>0.99)/S + length(unique(drop2[,"row"]))/S
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_99)
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_99)
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_95)
cbind(thres = c(0.2,0.25,0.3,0.35,0.4,0.45),type1= type1_97)
n_drop
drop1 = n_drop[sapply(n_drop,function(i) nrow(i) ==1)]%>% lift_dl(rbind)() # drop 1
sum(drop1[,2]!=1) # if trt2 or trt3 is dropped
drop2 = n_drop[sapply(n_drop,function(i) nrow(i) ==2)]%>% lift_dl(rbind)() # drop 2
sum(drop2[,2] ==3) # if trt3 is dropped
drop3 = n_drop[sapply(n_drop,function(i) nrow(i) ==3)]%>% lift_dl(rbind)(); drop3 # drop 3
rr<-
apply(dat_from_trials2[,,-drop2[,"row"]],3, function(d){
pos = sapply(c("trt2","trt3"), function(tr){
GetPosMean(R, x = d[,tr], v_sq = v_sq, mu0 = pr[tr,"Mean"], sig_sq = pr[tr,"Variance"], beta = beta)
})
# apply(d,2,mean)["trt3"]
# apply(pos,2, mean)["trt3"]
# pr_inf["mean","trt3"]
#
mean(apply(pos,1,diff) < 0)
})
sum(rr>0.99)/S + length(unique(drop2[,"row"]))/S
thres_drop = 0.35
# which datasets are dropped?
n_drop =  which(t(sucra2)< thres_drop, arr.ind = T)
n_drop = lapply(unique(n_drop[,1]), function(i){
d = n_drop[n_drop[,1]==i,]
switch(is.matrix(d)+1,matrix(d,nrow=1),d)%>%
`colnames<-`(c("row","col"))
})
drop1 = n_drop[sapply(n_drop,function(i) nrow(i) ==1)]%>% lift_dl(rbind)() # drop 1
sum(drop1[,2]!=1) # if trt2 or trt3 is dropped
drop2 = n_drop[sapply(n_drop,function(i) nrow(i) ==2)]%>% lift_dl(rbind)() # drop 2
sum(drop2[,2] ==3) # if trt3 is dropped
drop3 = n_drop[sapply(n_drop,function(i) nrow(i) ==3)]%>% lift_dl(rbind)(); drop3 # drop 3
rr<-
apply(dat_from_trials2[,,-drop2[,"row"]],3, function(d){
pos = sapply(c("trt2","trt3"), function(tr){
GetPosMean(R, x = d[,tr], v_sq = v_sq, mu0 = pr[tr,"Mean"], sig_sq = pr[tr,"Variance"], beta = beta)
})
# apply(d,2,mean)["trt3"]
# apply(pos,2, mean)["trt3"]
# pr_inf["mean","trt3"]
#
mean(apply(pos,1,diff) < 0)
})
sum(rr>0.99)/S + length(unique(drop2[,"row"]))/S
setwd("~/SSD/Rdocuments/ALEX report")
